C51 COMPILER V9.54   TIMER                                                                 03/12/2022 18:23:30 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE TIMER
OBJECT MODULE PLACED IN ..\Obj\timer.obj
COMPILER INVOKED BY: D:\Program Files (x86)\Keil\Keil_V533\C51\BIN\C51.EXE ..\HARDWARE\TIMER\timer.c LARGE OPTIMIZE(0,SP
                    -EED) BROWSE INCDIR(..\Sys;..\User;..\Hardware\ADC;..\Hardware\EEPROM;..\Hardware\GPIO;..\Hardware\INT;..\Hardware\PCA;..
                    -\Hardware\PIT;..\Hardware\PWM;..\Hardware\UART;..\HARDWARE\TIMER;..\Peripheral\ad7124_noos;..\Peripheral;..\Hardware\SPI
                    -;..\HARDWARE\WDT) DEBUG OBJECTEXTEND PRINT(.\Listings\timer.lst) TABS(2) OBJECT(..\Obj\timer.obj)

line level    source

   1          #include "timer.h"
   2          
   3          /***************************************************************/
   4          //ÂàùÂßãÂåñÁöÑinitValue‰∏∫ÈÄöËÆØÊ≥¢ÁâπÁéá
   5          /***************************************************************/
   6          
   7          u16 timer2Cnt = 0;
   8          u16 timer4Cnt = 0;
   9          
  10          extern u8 wptr;
  11          u8 *pWptr = &wptr;
  12          extern SqQueue sq;
  13          extern SqQueue nDataCntSq;
  14          extern DataStateEnum dataState;
  15          extern u8 rxBuffer[MAXMODBUSDATALENGTH];
  16          extern u8 *pRxBuffer;
  17          
  18          // void Timer0_init(bool irtEn, u32 initValue, u8 TMode, bool T0_1T, bool clkoutEn)
  19          // {
  20          //     TR0 = 0; //ÂÅúÊ≠¢ËÆ°Êï∞
  21          
  22          //     ET0 = irtEn;
  23          
  24          //     TMOD |= TMode;
  25          //     AUXR |= ((u8)T0_1T) << 6;                  //T12_1=0,12T;T12_1=1,1T
  26          //     TL0 = (65536 - Main_Fosc / initValue / 4); //ÂÆöÊó∂Âô®1Ë£ÖÂàùÂÄº
  27          //     TH0 = (65536 - Main_Fosc / initValue / 4) >> 8;
  28          
  29          //     if (clkoutEn)
  30          //     {
  31          //         INT_CLKO |= 0x01; //ËæìÂá∫Êó∂Èíü
  32          //     }
  33          //     else
  34          //     {
  35          //         INT_CLKO &= 0xfe; //‰∏çËæìÂá∫Êó∂Èíü
  36          //     }
  37          //     TR0 = 1; //‰ΩøËÉΩËÆ°Êï∞
  38          // }
  39          
  40          void Timer1_init(bool irtEn, u32 initValue, u8 TMode, bool T1_1T, bool clkoutEn)
  41          {
  42   1          TR1 = 0; //ÂÅúÊ≠¢ËÆ°Êï∞
  43   1      
  44   1          ET1 = irtEn;
  45   1      
  46   1          TMOD |= TMode;
  47   1          AUXR |= ((u8)T1_1T) << 6;                  //T12_1=0,12T;T12_1=1,1T
  48   1          TL1 = (65536 - Main_Fosc / initValue / 4); //ÂÆöÊó∂Âô®1Ë£ÖÂàùÂÄº
  49   1          TH1 = (65536 - Main_Fosc / initValue / 4) >> 8;
  50   1      
  51   1          if (clkoutEn)
  52   1          {
C51 COMPILER V9.54   TIMER                                                                 03/12/2022 18:23:30 PAGE 2   

  53   2              INT_CLKO |= 1 << 1; //ËæìÂá∫Êó∂Èíü
  54   2          }
  55   1          else
  56   1          {
  57   2              INT_CLKO &= ~(0 << 1); //‰∏çËæìÂá∫Êó∂Èíü
  58   2          }
  59   1      
  60   1          TR1 = 1; //‰ΩøËÉΩËÆ°Êï∞
  61   1      }
  62          
  63          void Timer2_init(bool irtEn, u32 initValue, u8 TMode, bool T2_1T, bool clkoutEn)
  64          {
  65   1          AUXR &= ~0x1c; //ÂÅúÊ≠¢ËÆ°Êï∞, ÂÆöÊó∂Ê®°Âºè, 12TÊ®°Âºè
  66   1          if (irtEn)
  67   1          {
  68   2              IE2 |= ET2; //ÂÖÅËÆ∏‰∏≠Êñ≠
  69   2          }
  70   1          else
  71   1          {
  72   2              IE2 &= ~ET2; //
  73   2          }
  74   1      
  75   1          TMOD |= TMode;
  76   1          T4T3M |= (((u8)T2_1T) << 1);               //1T mode
  77   1          T2L = (65536 - Main_Fosc / initValue / 4); //ÂÆöÊó∂Âô®2Ë£ÖÂàùÂÄºÔºåÂõ∫ÂÆö‰∏∫16‰ΩçÈáçËΩΩÊ®°Âºè
  78   1          T2H = (65536 - Main_Fosc / initValue / 4) >> 8;
  79   1      
  80   1          // INT_CLKO &= ((u8)irtEn) << 4 | 0xef;
  81   1          if (clkoutEn)
  82   1          {
  83   2              INT_CLKO |= 0x04; //ËæìÂá∫Êó∂Èíü
  84   2          }
  85   1          else
  86   1          {
  87   2              INT_CLKO &= ~0x04; //‰∏çËæìÂá∫Êó∂Èíü
  88   2          }
  89   1          AUXR |= (1 << 4); //ÂºÄÂßãËøêË°å
  90   1      }
  91          
  92          void Timer3_init(bool irtEn, u32 initValue, bool T3_1T, bool clkoutEn)
  93          {
  94   1          T4T3M &= ~0x0f; //ÂÅúÊ≠¢ËÆ°Êï∞
  95   1          if (irtEn)
  96   1          {
  97   2              IE2 |= ET3; //ÂÖÅËÆ∏‰∏≠Êñ≠
  98   2          }
  99   1          else
 100   1          {
 101   2              IE2 &= ~ET3;
 102   2          }
 103   1      
 104   1          T4T3M |= (((u8)T3_1T) << 1); //1T mode
 105   1      
 106   1          T3L = (65536 - Main_Fosc / initValue / 4); //ÂÆöÊó∂Âô®3Ë£ÖÂàùÂÄºÔºåÂõ∫ÂÆö‰∏∫16‰ΩçÈáçËΩΩÊ®°Âºè
 107   1          T3H = (65536 - Main_Fosc / initValue / 4) >> 8;
 108   1      
 109   1          // INT_CLKO &= ((u8)irtEn) << 5 | 0xDf;
 110   1      
 111   1          if (clkoutEn)
 112   1          {
 113   2              T4T3M |= 0x01; //ËæìÂá∫Êó∂Èíü
 114   2          }
C51 COMPILER V9.54   TIMER                                                                 03/12/2022 18:23:30 PAGE 3   

 115   1          else
 116   1          {
 117   2              T4T3M &= ~0x01; //‰∏çËæìÂá∫Êó∂Èíü
 118   2          }
 119   1          T4T3M |= (1 << 3); //‰ΩøËÉΩËÆ°Êï∞
 120   1      }
 121          
 122          void Timer4_init(bool irtEn, u32 initValue, bool T4_1T, bool clkoutEn)
 123          {
 124   1          T4T3M &= ~0xf0; //ÂÅúÊ≠¢ËÆ°Êï∞, ÂÆöÊó∂Ê®°Âºè, 12TÊ®°Âºè, ‰∏çËæìÂá∫Êó∂Èíü
 125   1          if (irtEn)
 126   1          {
 127   2              IE2 |= ET4; //ÂÖÅËÆ∏‰∏≠Êñ≠
 128   2          }
 129   1          else
 130   1          {
 131   2              IE2 &= ~ET4;
 132   2          }
 133   1      
 134   1          T4T3M |= (((u8)T4_1T) << 1); //1T mode
 135   1      
 136   1          T4L = (65536 - Main_Fosc / initValue / 4); //ÂÆöÊó∂Âô®4Ë£ÖÂàùÂÄº„ÄÇÂõ∫ÂÆö‰∏∫16‰ΩçÈáçËΩΩÊ®°Âºè
 137   1          T4H = (65536 - Main_Fosc / initValue / 4) >> 8;
 138   1      
 139   1          // INT_CLKO &= ((u8)irtEn) << 6 | 0xBf;
 140   1      
 141   1          if (clkoutEn)
 142   1          {
 143   2              T4T3M |= 0x10; //ËæìÂá∫Êó∂Èíü
 144   2          }
 145   1          else
 146   1          {
 147   2              T4T3M &= ~0x10; //‰∏çËæìÂá∫Êó∂Èíü
 148   2          }
 149   1          T4T3M |= (1 << 7); //ÂºÄÂßãËøêË°å
 150   1      }
 151          
 152          void Timer3_start(void)
 153          {
 154   1          T4T3M |= (1 << 3); //‰ΩøËÉΩËÆ°Êï∞
 155   1      }
 156          void Timer3_stop(void)
 157          {
 158   1          T4T3M &= ~0x0f; //ÂÅúÊ≠¢ËÆ°Êï∞
 159   1      }
 160          void Timer4_start(void)
 161          {
 162   1          T4T3M |= (1 << 7); //ÂºÄÂßãËøêË°å
 163   1      }
 164          void Timer4_stop(void)
 165          {
 166   1          T4T3M &= ~0xf0; //ÂÅúÊ≠¢ËÆ°Êï∞
 167   1      }
 168          // //========================================================================
 169          // // ÂáΩÊï∞: void timer0Isr (void) interrupt TIMER0_VECTOR
 170          // // ÊèèËø∞:  timer0‰∏≠Êñ≠ÂáΩÊï∞.
 171          // // ÂèÇÊï∞: none.
 172          // // ËøîÂõû: none.
 173          // // ÁâàÊú¨: V1.0, 2015-1-12
 174          // //========================================================================
 175          // void timer0Isr(void) interrupt TIMER0_VECTOR
 176          // {
C51 COMPILER V9.54   TIMER                                                                 03/12/2022 18:23:30 PAGE 4   

 177          // }
 178          
 179          //========================================================================
 180          // ÂáΩÊï∞: void timer1Isr (void) interrupt TIMER1_VECTOR
 181          // ÊèèËø∞:  timer1‰∏≠Êñ≠ÂáΩÊï∞.
 182          // ÂèÇÊï∞: none.
 183          // ËøîÂõû: none.
 184          // ÁâàÊú¨: V1.0, 2015-1-12
 185          //========================================================================
 186          // void timer1Isr(void) interrupt TIMER1_VECTOR
 187          // {
 188          //     DacSDI = ~DacSDI;
 189          // }
 190          
 191          //========================================================================
 192          // ÂáΩÊï∞: void timer2Isr (void) interrupt TIMER2_VECTOR
 193          // ÊèèËø∞:  timer2‰∏≠Êñ≠ÂáΩÊï∞.
 194          // ÂèÇÊï∞: none.
 195          // ËøîÂõû: none.
 196          // ÁâàÊú¨: V1.0, 2015-1-12
 197          //========================================================================
 198          void timer2Isr(void) interrupt TIMER2_VECTOR
 199          {
 200   1      
 201   1          if (timer2Cnt++ > 100)
 202   1          {
 203   2              timer2Cnt = 0;
 204   2              if (++dacChn >= MAXAD7124CHNS)
 205   2              {
 206   3                  dacChn = 0;
 207   3              }
 208   2          }
 209   1      }
 210          
 211          //========================================================================
 212          // ÂáΩÊï∞: void timer3Isr (void) interrupt TIMER3_VECTOR
 213          // ÊèèËø∞:  timer3‰∏≠Êñ≠ÂáΩÊï∞.
 214          // ÂèÇÊï∞: none.
 215          // ËøîÂõû: none.
 216          // ÁâàÊú¨: V1.0, 2015-1-12
 217          //========================================================================
 218          void timer3Isr(void) interrupt TIMER3_VECTOR
 219          {
 220   1          modbusDataGapCnt++;
 221   1          if (modbusDataGapCnt > MODBUS_T_x_CNT(3.5))
 222   1          {
 223   2              dataState = IS_ADDR;
 224   2              Timer3_stop();
 225   2              return;
 226   2          }
 227   1      
 228   1          if (modbusDataGapCnt > MODBUS_T_x_CNT(1.5))
 229   1          {
 230   2              dataState = IS_IDLE;
 231   2              if (wptr == 0) //Ê∂àÈô§modbusDataGapCntÂú®1.5Âíå3.5Â≠óÁ¨¶Êó∂Èó¥‰πãÈó¥ÈáçÂ§çË∑ë‰∏ãÈù¢ÁöÑÁ®ãÂ∫èÊÆµÔº
             -åËäÇÁúÅÊåáÈíàpRxBufferÂÆöÂêëÂíåmemsetÁöÑÊó∂Èó¥ÔºàÂ§ßÁ∫¶30msÔºâ
 232   2              {
 233   3                  return;
 234   3              }
 235   2              if (wptr > 7) //ËøõÂÖ•Ëøô‰∏™ÈÄªËæëÁöÑÊòØÊúâÊïàÊï∞ÊçÆË∂ÖËøá7‰∏™Ôºàwptr++‰∏çÂê´Âú∞ÂùÄÔºâÔºåËÆ§‰∏∫Ëøô
             -wptr‰∏™Êï∞ÊçÆÊòØÊúâÊïàÁöÑÔºà‰ΩÜÊú™ÁªècrcÔºâ
 236   2              {
C51 COMPILER V9.54   TIMER                                                                 03/12/2022 18:23:30 PAGE 5   

 237   3                  EnQueue(&sq, rxBuffer, wptr);
 238   3                  EnQueue(&nDataCntSq, pWptr, 1);
 239   3              }
 240   2              pRxBuffer = rxBuffer;
 241   2              memset(pRxBuffer, 0, wptr);
 242   2              wptr = 0;
 243   2          }
 244   1      }
 245          
 246          //========================================================================
 247          // ÂáΩÊï∞: void timer4Isr (void) interrupt TIMER4_VECTOR
 248          // ÊèèËø∞:  timer4‰∏≠Êñ≠ÂáΩÊï∞.
 249          // ÂèÇÊï∞: none.
 250          // ËøîÂõû: none.
 251          // ÁâàÊú¨: V1.0, 2015-1-12
 252          //========================================================================
 253          void timer4Isr(void) interrupt TIMER4_VECTOR
 254          {
 255   1          timer4Cnt++;
 256   1          if (timer4Cnt == ADCSETUPTIME) //80ms
 257   1          {
 258   2              timer4Cnt = 0;
 259   2              IE1 = 0; //Ê∏ÖINT1Ê†áÂøó‰Ωç
 260   2              EX1 = 1; //INT1‰∏≠Êñ≠ÂºÄ
 261   2              P10 = ~P10;
 262   2          }
 263   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1056    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     25    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     12    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
